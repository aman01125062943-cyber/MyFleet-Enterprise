[
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "db132d51-b1a1-4564-b109-efd679e03b84",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC001-Onboarding and full DB setup execution",
    "description": "Run full_db_setup.sql on a fresh Supabase project and verify required schemas, tables, RPCs, roles and default org bootstrap are created without errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open Supabase new-project page to provision a fresh project (create a test DB) so the SQL can be executed.\n        await page.goto(\"https://app.supabase.com/new\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a fresh tab and navigate to the Supabase web app (https://app.supabase.com/) to reach the project creation or login UI. If that fails, try alternate Supabase URLs or report website issue.\n        await page.goto(\"https://app.supabase.com/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Supabase web app (https://app.supabase.com/) in a new tab and wait for the SPA to load; then inspect the page for interactive elements to create a new project (e.g., 'Create new project' button/inputs). If the SPA still fails to load, try an alternate Supabase URL or report website issue.\n        await page.goto(\"https://app.supabase.com/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Database setup completed successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected full_db_setup.sql to execute and create the required schemas, tables (users, orgs, vehicles, drivers, trips, assets, expenses, roles, permissions, audit_logs), RPCs with correct signatures, and a default admin/org bootstrap (with an org_id), but the success message 'Database setup completed successfully' was not found\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120843980377//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:14.983Z",
    "modified": "2026-02-03T12:14:05.162Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "fba20611-0eb6-4c26-825c-52a15c254644",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC002-Multi-tenant data isolation (org_id enforcement)",
    "description": "Verify that data is strictly partitioned by org_id: a user from Org B cannot list, view, create, or update resources belonging to Org A.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the API root or docs (e.g., /api) to discover endpoints to create orgs/users and test cross-org access.\n        await page.goto(\"http://localhost:5174/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load likely API docs/openapi by navigating to /openapi.json to discover endpoints (or detect a JSON schema).\n        await page.goto(\"http://localhost:5174/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try other likely API/docs endpoints to locate an OpenAPI spec or API endpoints so resources can be created via API calls (openapi.yaml, swagger.json, /docs, /redoc, /api/openapi.json, /api/openapi.yaml).\n        await page.goto(\"http://localhost:5174/openapi.yaml\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/swagger.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open /api/openapi.json (in a new tab) to try to retrieve the raw OpenAPI JSON/YAML so endpoints (orgs, users, auth, vehicles, trips, assets) and schemas can be discovered.\n        await page.goto(\"http://localhost:5174/api/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to discover API resource endpoints by requesting common resource paths. Start by opening /api/organizations (or /api/organizations/) to see if JSON is returned.\n        await page.goto(\"http://localhost:5174/api/organizations\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Discover an API endpoint or raw JSON response for organization/user/auth/vehicle resources so the test plan can proceed. Start by attempting the likely resource path /organizations to see if the API responds with JSON or an error.\n        await page.goto(\"http://localhost:5174/organizations\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open /api/v1/openapi.json in a new tab to attempt to retrieve the OpenAPI specification. If that is empty, try alternative versioned OpenAPI paths (e.g., /api/v2/openapi.json) next.\n        await page.goto(\"http://localhost:5174/api/v1/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a likely resource endpoint that has not yet been tried: /api/v1/organizations (retrieve raw JSON or error response). If that yields no useful content, proceed to try other likely versioned resource endpoints (e.g., /api/v1/vehicles, /api/v1/auth/login) in subsequent steps.\n        await page.goto(\"http://localhost:5174/api/v1/organizations\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open /api/v1/vehicles in a new tab to look for a raw JSON API response or an error that reveals available endpoints/schemas.\n        await page.goto(\"http://localhost:5174/api/v1/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to a likely authentication endpoint to reveal API behavior. Open http://localhost:5174/api/v1/auth/login (new tab) and extract the raw response to discover auth/login API shape or error.\n        await page.goto(\"http://localhost:5174/api/v1/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a likely resource endpoint that has not yet been checked (/api/v1/users) to attempt to obtain raw JSON or an error response revealing API shape so the test plan can proceed.\n        await page.goto(\"http://localhost:5174/api/v1/users\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120843663594//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:14.989Z",
    "modified": "2026-02-03T12:14:04.879Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "fea4b5df-e674-4c73-b2ca-557154e4df6c",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC003-RBAC enforcement across RPCs and API endpoints",
    "description": "Verify role-based access control: admin, user, driver have access only to permitted RPCs and endpoints; forbidden actions return 403.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the API/docs endpoints to locate RPC endpoints and/or backend routes so seeding and RPC calls can be executed (try /api, /rpc, /docs).\n        await page.goto(\"http://localhost:5174/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the page 'Reload' button to retry connecting to the local server and re-check the /api or root pages.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to reach backend docs or RPC endpoints by navigating to http://localhost:5174/docs to locate available RPC routes and API details.\n        await page.goto(\"http://localhost:5174/docs\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120843855623//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:14.995Z",
    "modified": "2026-02-03T12:14:05.019Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "16a625d4-7852-40b4-907a-6a1601813e70",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC004-Authentication and session lifecycle",
    "description": "Verify login succeeds with valid credentials, tokens/sessions are issued, logout revokes session, and expired tokens are rejected.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application using direct navigation (last-resort) to attempt to load the SPA, then re-check the page for interactive elements.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait longer for the SPA to initialize (10s). If still blank, perform a direct navigation (reload) to http://localhost:5174 to attempt to load the SPA, then re-check the page for interactive elements (login form/buttons).\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab and request a backend health/auth endpoint (e.g., /api/health or /api/auth) to verify the server and to use the API path for creating a test user and performing login if frontend is unavailable.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend auth endpoint (http://localhost:5174/api/auth) in a new tab and extract the full response text/JSON and any endpoint hints. If empty, try other auth-related endpoints (/api/login, /api/users).\n        await page.goto(\"http://localhost:5174/api/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend auth/login endpoint to extract any JSON or hints (try /api/login). If empty, proceed to other likely auth endpoints (/api/users, /api/register, /api/auth/session).\n        await page.goto(\"http://localhost:5174/api/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend endpoint /api/users in a new tab and extract the full response (JSON/text/headers). If empty, iterate through remaining endpoints: /api/register, /api/auth/session, /auth, /api/me, /api/logout, /api/token/refresh.\n        await page.goto(\"http://localhost:5174/api/users\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the next backend auth endpoint (/api/register) in a new tab and extract the full page text/JSON and any status messages or endpoint hints; if empty, iterate to the remaining endpoints.\n        await page.goto(\"http://localhost:5174/api/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the next backend endpoint /api/auth/session in a new tab and inspect/extract its response (full text/JSON/headers) to locate auth APIs since frontend is blank.\n        await page.goto(\"http://localhost:5174/api/auth/session\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend endpoint /api/me in a new tab and extract full response (page text, JSON body if any, status messages, and response headers or endpoint hints). If empty, iterate to next endpoint (/api/logout or /api/token/refresh).\n        await page.goto(\"http://localhost:5174/api/me\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend logout endpoint (/api/logout) in a new tab and extract its full response (page text, JSON body, status messages, headers, and any endpoint hints).\n        await page.goto(\"http://localhost:5174/api/logout\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the /auth endpoint in a new tab and extract the full response (page text, JSON body if any, status messages, headers, and any endpoint hints).\n        await page.goto(\"http://localhost:5174/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with test credentials and click the secure login button to try to log in and capture session tokens/response.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[1]/div[2]/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[1]/div[2]/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[1]/div[2]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the auth session endpoint to verify whether login succeeded and to capture session token and user metadata. If session present, extract response; if not, try /api/me or other auth endpoints next.\n        await page.goto(\"http://localhost:5174/api/auth/session\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill username and password fields on the displayed login form and click the secure login button to attempt login and then check session/token endpoints.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[1]/div[2]/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[1]/div[2]/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[1]/div[2]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120843968363//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.001Z",
    "modified": "2026-02-03T12:14:05.047Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "bdaf7ce2-9bc5-4e28-8d43-ac2d8d85bbef",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC005-Fleet - Vehicle CRUD operations and DB consistency",
    "description": "Verify create, read, update, delete vehicle flows through UI/API and DB reflects consistent state including org scoping and validations.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly for the SPA to load, then reload the app URL to attempt to recover from the white screen.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Force a cache-busted reload of the app (add query param) and wait for the SPA to initialize, then re-check interactive elements and page content.\n        await page.goto(\"http://localhost:5174/?_ts=1700000000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait 5 seconds, then perform another cache-busted reload of the app (different query param) and wait 5 seconds to check if the SPA renders and interactive elements appear.\n        await page.goto(\"http://localhost:5174/?_ts=1700000001\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend API health endpoint to determine if the API is reachable (will try GET http://localhost:5174/api/health). If that fails, try other common endpoints (/api/ping, /api/v1/health) or open the API server port.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the next API probe endpoint /api/ping to retrieve its raw response body. If /api/ping yields no content, continue probing /api/v1/health and vehicle-related endpoints and then perform CRUD via API.\n        await page.goto(\"http://localhost:5174/api/ping\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /api/v1/health and extract the raw response body to determine API health. If that returns no content, plan to probe /api/vehicles (GET) next.\n        await page.goto(\"http://localhost:5174/api/v1/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the vehicles collection endpoint to check API availability and retrieve any vehicle data (GET /api/vehicles). If it returns content, extract raw response to continue CRUD tests; if empty, continue probing other vehicle-related endpoints or report API unreachable.\n        await page.goto(\"http://localhost:5174/api/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/177012084399848//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.006Z",
    "modified": "2026-02-03T12:14:05.151Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "fcb69c21-3bb9-4592-822b-2959487b4bea",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC006-Driver CRUD and profile RBAC",
    "description": "Verify adding, editing and deleting drivers, and that drivers can access driver-specific features while not accessing admin-only features.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the login route to get the application UI (navigate to /login). If that fails, try other routes or report site issue.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait a bit to allow SPA to initialize, then attempt a reload by navigating to the root URL (http://localhost:5174/). After navigation, check for interactive elements. If still blank, plan next: try alternative app routes (/drivers or /app) or report website issue.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the /drivers route (http://localhost:5174/drivers) to attempt to load the SPA. If that fails, try /app and /dashboard or report a website issue.\n        await page.goto(\"http://localhost:5174/drivers\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the /app route (http://localhost:5174/app) to attempt to load the SPA. If that fails, try /dashboard or report website issue.\n        await page.goto(\"http://localhost:5174/app\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:5174/dashboard to attempt to load the SPA and look for interactive elements (login, navigation).\n        await page.goto(\"http://localhost:5174/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120844030042//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.012Z",
    "modified": "2026-02-03T12:14:05.155Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "ea88c7c3-cc17-4e1e-9252-8182028e031c",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC007-Trip scheduling and vehicle availability (conflict prevention)",
    "description": "Verify scheduling a trip assigns driver and vehicle, updates vehicle status, and prevents double-booking of the same vehicle/time.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the SPA by waiting briefly then reloading the page. If the page remains blank, attempt opening the app in a new tab or call known API endpoints directly to continue tests.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app in a new tab using /index.html to try to bypass SPA white-screen. If that doesn't load, try the hash route /#/ in a new tab, then call backend health API if UI remains blank.\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/#/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend health endpoint to determine whether the server is up and to continue tests via API if the UI remains unavailable. Open http://localhost:5174/api/health in a new tab.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the API root (/api/) in a new tab to enumerate available endpoints and check backend responses; if /api/ returns useful JSON, proceed with API calls to create vehicle, driver, and schedule trips. If /api/ is also empty, continue probing backend endpoints (e.g., /api/vehicles, /api/drivers) to determine server status.\n        await page.goto(\"http://localhost:5174/api/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open /api/vehicles in a new tab to retrieve its response (check for JSON listing). If empty, continue probing /api/drivers and /api/trips. If backend returns useful JSON, proceed with API calls to create vehicle, driver, and schedule trips per the test plan.\n        await page.goto(\"http://localhost:5174/api/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open /api/drivers in a new tab and retrieve its response body to determine if the backend API is responsive. If /api/drivers is empty, continue probing /api/trips next.\n        await page.goto(\"http://localhost:5174/api/drivers\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend trips endpoint to probe API responsiveness: GET http://localhost:5174/api/trips and retrieve its response body. If empty, continue probing other API endpoints or report server unreachable.\n        await page.goto(\"http://localhost:5174/api/trips\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe for API documentation or alternate health endpoints to determine backend availability â€” try /swagger/index.html (or /docs, /openapi.json, /healthz) so tests can continue via API if UI remains unavailable.\n        await page.goto(\"http://localhost:5174/swagger/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120844021696//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.018Z",
    "modified": "2026-02-03T12:14:05.060Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "bd8613ef-4313-4e99-a5b4-19f1ac642426",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC008-Trip cost calculator correctness and validations",
    "description": "Verify the trip calculator computes cost from inputs (distance, fuel consumption, fuel price, tolls, additional fees) and enforces input validation including zero/negative edge cases.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait a short time for the SPA to initialize, then reload the page (navigate to the same URL) if the UI is still blank to try to recover the app.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open http://localhost:5174/index.html in a new tab to check whether static HTML loads (inspect for missing SPA bundle).\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/177012084398231//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.025Z",
    "modified": "2026-02-03T12:14:05.112Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "c0172127-2deb-47d0-a99f-2cdbd25da7e4",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC009-Financial entries linkage and net profit calculation",
    "description": "Verify that expenses and revenues can be linked to assets/vehicles and that net profit aggregations reflect linked entries correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to reach a usable UI by navigating to the login page (or reload a route) so the application can be accessed to create vehicle, revenues and expenses.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try an alternate route to load the SPA (hash route) by navigating to http://localhost:5174/#/login to force the client router to render the login UI.\n        await page.goto(\"http://localhost:5174/#/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try alternative host and reload: open a new tab to http://127.0.0.1:5174 to see if the SPA loads; if that fails next will try index.html or add cache-bypass query parameters.\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading the static entry file to bypass SPA routing: navigate to http://127.0.0.1:5174/index.html (if blank, next will add a cache-bypass query).\n        await page.goto(\"http://127.0.0.1:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the SPA with a cache-bypass query parameter to force fresh assets: navigate to http://127.0.0.1:5174/index.html?_t=1 and check for interactive elements.\n        await page.goto(\"http://127.0.0.1:5174/index.html?_t=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check whether the dev server/static assets are being served by requesting known dev endpoints or client assets to diagnose blank page (fetch vite client). If that returns content, proceed to load app assets; otherwise report server/static asset issue.\n        await page.goto(\"http://127.0.0.1:5174/@vite/client\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Diagnose server/static asset responses by requesting a likely client asset (main.js) to see if the dev server is serving transformed JS or returning an error. If that returns content, inspect it to determine why the SPA isn't initializing; if it returns 404 or error, report a static asset/server issue.\n        await page.goto(\"http://127.0.0.1:5174/main.js\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120843974649//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.032Z",
    "modified": "2026-02-03T12:14:05.054Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "e92fda31-fa1a-4bdb-bc8a-a7f58bb24b5a",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC010-Dashboard KPIs accuracy vs. DB seed data",
    "description": "Validate that dashboard metrics (total revenue, total expenses, trip count, vehicle availability) display values consistent with direct DB aggregations for seeded datasets.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to locate and call a deterministic seeding endpoint (try /seed) to inject the OrgTest dataset so DB-based aggregations can be compared.\n        await page.goto(\"http://localhost:5174/seed\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to call backend seeding endpoint at /api/seed (GET) to inject the OrgTest dataset so DB aggregations become available for verification.\n        await page.goto(\"http://localhost:5174/api/seed\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Call the backend deterministic seed endpoint with explicit org parameter (/api/seed?org=OrgTest) and wait for the response. Then inspect the page for any confirmation text or JSON response. If that returns nothing, try alternate seed endpoints or query a status endpoint.\n        await page.goto(\"http://localhost:5174/api/seed?org=OrgTest\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend/service status endpoint to determine if backend is up and whether seeding can be confirmed (navigate to /api/health or /api/status). If healthy, attempt alternate seed endpoints or request JSON response from seed endpoint.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button (index 74) on the error page to attempt to recover the connection and re-check the backend health/seed endpoints.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open a new tab and navigate to http://127.0.0.1:5174/index.html to check whether the SPA static entry or a different host binding responds.\n        await page.goto(\"http://127.0.0.1:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend health on the 127.0.0.1 host and see if the API responds (call /api/health). If healthy, then call deterministic seed endpoint (/api/seed?org=OrgTest). If no response, report backend unreachable.\n        await page.goto(\"http://127.0.0.1:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab and navigate to http://localhost:5174/api/health to check backend health/JSON response (if available). If that returns nothing, report backend unreachable and stop.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open http://localhost:5174/index.html in a new tab to check whether static index or assets respond (if blank, try /favicon.ico or report backend unreachable).\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe whether the server is serving static assets by requesting a small static file (favicon). If favicon returns binary/OK, proceed to check manifest or JS assets; if blank/ERR, report backend unreachable and stop.\n        await page.goto(\"http://localhost:5174/favicon.ico\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the visible Reload button on the current error page to attempt recovery and then re-check backend endpoints (health/seed). If reload fails, inspect resulting page for new interactive elements or error details.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt the Reload button again to try to recover the SPA and then re-check backend health/seed endpoints if the page changes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120844022129//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.038Z",
    "modified": "2026-02-03T12:14:05.147Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "d945f7b0-ef56-4559-9944-7e4161a374c3",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC011-Charts interactivity and filter-driven updates (Recharts)",
    "description": "Verify Recharts visualizations update when filters/time-range change and tooltips/hover interactions show expected data points.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page (navigate to the same URL) to force the SPA to initialize, then inspect the page for login/dashboard/Analytics elements.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app in a new browser tab (fresh load of http://localhost:5174/) to see if the SPA initializes; inspect the new tab for interactive elements. If still blank, try loading via 127.0.0.1 next.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app using http://127.0.0.1:5174 in a new tab and inspect the page for interactive elements (login/dashboard/navigation). If the SPA loads, proceed to the Analytics/Dashboard page.\n        await page.goto(\"http://127.0.0.1:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to reach the app via its login entrypoint. Navigate to http://127.0.0.1:5174/login and inspect the page for login fields or dashboard/navigation elements. If login form appears, attempt sign-in with test credentials.\n        await page.goto(\"http://127.0.0.1:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading a static entry (index.html) for the app to recover the UI. If that fails, attempt other common entry routes (/dashboard, /analytics) or use the root host localhost:5174 with index.html.\n        await page.goto(\"http://127.0.0.1:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt a different entrypoint â€” navigate to /dashboard to see if the SPA renders from that route. If still blank, try /analytics next, then escalate/report site issue.\n        await page.goto(\"http://127.0.0.1:5174/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the current page with a cache-busting query parameter to force SPA assets to reload, then inspect the page for interactive elements (login/dashboard/analytics). If still blank, try other diagnostics (alternate entrypoints or report website issue).\n        await page.goto(\"http://127.0.0.1:5174/?_cache_bust=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try an alternate entrypoint: open the analytics route (/analytics) on the app host in a new tab to see if the SPA renders from that route.\n        await page.goto(\"http://127.0.0.1:5174/analytics\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check whether the server is returning static assets by requesting the manifest (manifest.json). If manifest loads (JSON/200) inspect contents; if 404 or no response, try other diagnostics (favicon, /robots.txt or report site issue).\n        await page.goto(\"http://127.0.0.1:5174/manifest.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab and request /robots.txt on the app host (http://127.0.0.1:5174/robots.txt) to check whether the server returns plain-text assets; use the response to decide next diagnostics.\n        await page.goto(\"http://127.0.0.1:5174/robots.txt\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120844042289//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.043Z",
    "modified": "2026-02-03T12:14:05.193Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "7bedf38e-1bba-4642-ae99-f42eebc23d31",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC012-Assets migration and permission fixes execution",
    "description": "Run assets_migration.sql and fix_assets_permissions.sql, verify they execute cleanly, update schema as expected, and apply correct row-level permissions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to locate the migration SQL files by requesting them directly from the dev server (try fetching /assets_migration.sql). If not served, will try other likely paths or ask for DB access/paths.\n        await page.goto(\"http://localhost:5174/assets_migration.sql\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try fetching the migration SQL files from likely alternative paths on the dev server (migrations/, sql/, db/migrations/). If files are not served, request DB access or the SQL files directly.\n        await page.goto(\"http://localhost:5174/migrations/assets_migration.sql\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/migrations/fix_assets_permissions.sql\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/sql/assets_migration.sql\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the migrations SQL file to retrieve its contents (try /migrations/assets_migration.sql) so the SQL can be reviewed and executed.\n        await page.goto(\"http://localhost:5174/migrations/assets_migration.sql\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fetch the raw SQL contents from an alternate endpoint that previously responded: navigate to /sql/assets_migration.sql to retrieve assets_migration.sql contents, then fetch /migrations/fix_assets_permissions.sql to retrieve the permissions script.\n        await page.goto(\"http://localhost:5174/sql/assets_migration.sql\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/migrations/fix_assets_permissions.sql\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Retry loading the current endpoint by clicking the Reload button to attempt to retrieve /sql/assets_migration.sql again. If reload fails, attempt alternative retrieval paths or request DB access/SQL files.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try to load the raw assets_migration.sql from the alternate endpoint /migrations/assets_migration.sql to retrieve its contents. If that succeeds, then fetch fix_assets_permissions.sql next.\n        await page.goto(\"http://localhost:5174/migrations/assets_migration.sql\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Assets migration and permissions update completed successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected confirmation that assets_migration.sql and fix_assets_permissions.sql executed and updated the schema and applied row-level permissions (message 'Assets migration and permissions update completed successfully') but the success message did not appear; migrations may have errored or the UI did not report success\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120843910975//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.050Z",
    "modified": "2026-02-03T12:14:05.200Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "3ca840c4-c4ad-4fe0-86c9-5ba6e00cfa4c",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC013-RPCs marked SECURITY DEFINER enforce caller checks and do not leak sensitive data",
    "description": "Verify SECURITY DEFINER functions behave securely: enforce additional permission checks, do not expose secret columns, and only perform privileged actions when business checks pass.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page (navigate again to http://localhost:5174) to attempt to load the SPA so interactive elements and links become available.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the SPA by navigating again to http://localhost:5174, wait 3 seconds, then inspect the page for interactive elements or links to API/docs.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the static entry /index.html to check if the app's static file serves. If that fails, probe backend health endpoints (/health, /api) to discover available API routes and RPC endpoints.\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend health/API endpoints to discover API or RPC routes. Open /health in a new tab to check service status and available endpoints.\n        await page.goto(\"http://localhost:5174/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend endpoints to discover available RPC routes and API documentation. Open /rpc, /openapi.json, and /api each in a new tab and wait for responses; then inspect the returned content to identify SECURITY DEFINER functions or API docs.\n        await page.goto(\"http://localhost:5174/rpc\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120844138527//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.057Z",
    "modified": "2026-02-03T12:14:05.110Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "8bbbe060-9b3e-490b-94ba-39015fce5cf0",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC014-Database migrations idempotency and safe re-run",
    "description": "Verify that running migration scripts multiple times is idempotent where intended and that re-running does not create duplicates or leave the DB in inconsistent state.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the web page and re-check for any UI content or error responses. If still blank, attempt to reach likely backend endpoints (health or migration endpoints) or request DB access/ability to run migration scripts.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a backend health/migration endpoint to determine whether the server and DB are reachable (try /api/health). If that responds, attempt to find migration endpoints or logs; if not, continue investigating other backend endpoints.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to reach a backend migration endpoint to run or trigger migrations (e.g., /api/migrate). If that endpoint is not available, try alternative common endpoints (e.g., /api/migrations, /api/db/migrate).\n        await page.goto(\"http://localhost:5174/api/migrate\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try backend migration/status endpoints that may run or report migrations (start with /api/migrations). If those return no usable output, try alternative endpoints (/api/db/migrate) or request logs/DB access so migrations can be executed outside the UI.\n        await page.goto(\"http://localhost:5174/api/migrations\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt alternative backend migration endpoint (/api/db/migrate). If that returns blank as well, request direct DB access, logs, or ability to run the SQL migration scripts on the DB (or provide a migration API that returns JSON status) so idempotency checks can be performed.\n        await page.goto(\"http://localhost:5174/api/db/migrate\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120186898872//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.063Z",
    "modified": "2026-02-03T12:13:36.311Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "c74b57aa-c831-4bc9-afc2-c62322816211",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC015-Fleet search and pagination performance at scale",
    "description": "Verify list/search of fleet (vehicles) returns results and response times remain within performance targets (300-500ms) for medium datasets (1k-5k records).",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application by navigating to the root URL again and wait for the SPA to initialize. If the page remains blank, try navigating to /login or /health to find usable endpoints.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /login to check if the app exposes a login page; if that fails, navigate to /health to check backend status. Identify any API endpoints or pages usable for seeding DB and measuring response times.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend health API endpoint to confirm backend status and look for API endpoints usable for seeding the database (then attempt seeding via API if available). If health endpoint is not available, report website/backend issue.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend list API to verify vehicle listing endpoint and measure response time (try GET /api/vehicles?limit=1). Open it in a new tab so backend responses can be inspected independently; then wait briefly to allow response.\n        await page.goto(\"http://localhost:5174/api/vehicles?limit=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the vehicle list API with a larger limit to check if backend returns JSON and measure response time (navigate to /api/vehicles?limit=100 in a new tab and wait). If the response is still blank, try /api/ to discover endpoints or report backend issue.\n        await page.goto(\"http://localhost:5174/api/vehicles?limit=100\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open API root (http://localhost:5174/api/) to discover available endpoints (seed, health, vehicles) and confirm whether backend returns JSON. If API root is blank, continue probing likely API endpoints (e.g., /api/seed, /api/dev/seed, /api/setup) or report backend issue.\n        await page.goto(\"http://localhost:5174/api/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to seed the database via API endpoints (try /api/seed). If seed endpoint exists, wait and then request /api/vehicles?limit=100 to verify records and measure response time. If /api/seed is not available, try /api/dev/seed then /api/setup.\n        await page.goto(\"http://localhost:5174/api/seed\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/api/vehicles?limit=100\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe API discovery and alternative seed endpoints to locate a working API (try /api/openapi.json, /swagger, and /api/dev/seed). If these return no usable responses, report backend issue and stop.\n        await page.goto(\"http://localhost:5174/api/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/swagger\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/api/dev/seed\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Showing 1-50 of 5000 vehicles').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the fleet listing to show search results (e.g., 'Showing 1-50 of 5000 vehicles') after seeding 5,000 records and performing search/pagination. The expected UI indicator did not appear â€” the vehicle list/search may have failed, backend endpoints may be unavailable, or response performance/contents are not within expected targets.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120399246332//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.069Z",
    "modified": "2026-02-03T12:13:36.322Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "aac45d58-cc52-48c1-9556-8e71735e78eb",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC016-Frontend navigation and main flows without console errors",
    "description": "Verify primary UI flows (login -> dashboard -> fleet -> vehicle detail -> edit -> save) work end-to-end and the frontend generates no runtime console errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application (refresh/navigate) to attempt to load the SPA and then check for interactive elements and console errors.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application (navigate to http://localhost:5174), wait for it to load, then check for interactive elements and console errors.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the application in a new browser tab (fresh context) and wait for it to load, then check for interactive elements and any console errors. If page still blank, attempt alternative navigation or escalate.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the static index file (http://localhost:5174/index.html) to see if a plain HTML is served; then request favicon to confirm server responds. After that, inspect page content and look for interactive elements or error responses.\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:5174/favicon.ico\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the visible 'Reload' button (index 77) on the current 404 page to attempt to refresh the resource and then re-check the page for interactive application elements and console errors.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Reload' button (index 207) again and wait 2 seconds to see if the root SPA loads or the page changes; then inspect page for interactive application elements and any console/HTTP error indications.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try loading the application using the loopback IP (http://127.0.0.1:5174) in a fresh tab to bypass potential hostname/resolution issues; wait for the page to load and then inspect for interactive elements or error indications.\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading the static entry explicitly on the loopback address: request http://127.0.0.1:5174/index.html, wait for it to load, then request /favicon.ico to check server responses and determine whether the server is serving static assets.\n        await page.goto(\"http://127.0.0.1:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://127.0.0.1:5174/favicon.ico\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the app from an alternate likely dev port to determine whether the dev server is running on a different port (try http://127.0.0.1:5173 in a new tab). If that fails, follow-up will be to try other ports or activate console/network capture.\n        await page.goto(\"http://127.0.0.1:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading the app on a different common dev port to determine if the dev server is running elsewhere (open http://127.0.0.1:3000 in a new tab), wait for load, then inspect for interactive elements and errors.\n        await page.goto(\"http://127.0.0.1:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open fresh tabs for alternate common dev hostnames/ports to find the running frontend: try http://localhost:5173 in a new tab; if that returns an error, try http://localhost:3000 in a new tab. Inspect resulting pages for interactive elements or errors (will follow up with console capture if pages still fail).\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Vehicle updated successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected to see 'Vehicle updated successfully' after editing and saving a vehicle on the fleet vehicle detail page â€” the edit/save did not show a success notification (possible frontend notification failure, backend persistence issue, or runtime console errors)\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/177012047308786//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.074Z",
    "modified": "2026-02-03T12:13:36.330Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "275e60d1-1776-472c-bbcb-c66419a67c18",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC017-Graceful error handling when DB is unavailable",
    "description": "Simulate database outage and verify the backend returns appropriate 5xx responses and the frontend surfaces a friendly error message without leaking internals.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a backend/health diagnostic endpoint to determine whether the server is up and to capture status code/body (try /health). If that fails, try /api/health or /ping endpoints next.\n        await page.goto(\"http://localhost:5174/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request backend health endpoint that commonly exposes service status (/api/health). Capture response status and body. If no response, try /ping or /status next.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to a common lightweight diagnostic endpoint (/ping) to capture its HTTP status and body so backend availability can be confirmed. If /ping returns a response, record status/body; if blank, try /status next.\n        await page.goto(\"http://localhost:5174/ping\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to an alternate health/status endpoint (/status) to capture HTTP response status/body. If blank, plan next checks: try /status.json, /server-status, or open API host endpoints. If /status also returns empty, report inability to reach backend responses and request environment-level intervention (bring down DB) before continuing.\n        await page.goto(\"http://localhost:5174/status\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Service temporarily unavailable. Please try again later.').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Verify frontend surfaces a user-friendly 'service unavailable' message with retry guidance when the backend (DB) is down â€” expected 'Service temporarily unavailable. Please try again later.' to be visible, but it was not.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/177012022621421//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.081Z",
    "modified": "2026-02-03T12:13:36.339Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "8f411fe7-1203-4d2e-89d0-9ae7021f2a86",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC018-Role management CRUD and permission propagation",
    "description": "Verify admin can create/modify/delete roles and permission sets and that changes propagate to user access in real time or after accepted refresh semantics.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Force a cache-busting navigation to http://localhost:5174/?_cacheBust=1, wait for the page to load, then re-check for interactive elements and visible UI.\n        await page.goto(\"http://localhost:5174/?_cacheBust=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> As a last-resort navigation, load http://localhost:5174/index.html to check server response and reveal any error output or non-root asset serving issues.\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the dev server by requesting a health endpoint to check whether the server is responding (HTTP status/body). If health endpoint is unavailable, examine a static asset (manifest or JS) next.\n        await page.goto(\"http://localhost:5174/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the static manifest (http://localhost:5174/manifest.json) to inspect the server response and confirm whether static assets are being served; use the response to decide next debugging steps.\n        await page.goto(\"http://localhost:5174/manifest.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the favicon endpoint to check whether static assets are being served (http://localhost:5174/favicon.ico) in a new tab and inspect the response.\n        await page.goto(\"http://localhost:5174/favicon.ico\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the visible \"Reload\" button to retry the request, wait for the page to reload, then extract the full visible page text or error information to determine server response.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible Reload button (index 200) and wait for the page to reload, then re-check for app UI or interactive elements.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open a new tab and navigate to http://127.0.0.1:5174/ to check whether the dev server responds differently and to capture the full response (HTML or error) for diagnosis.\n        await page.goto(\"http://127.0.0.1:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://127.0.0.1:5174/health and extract the full response body (visible page text or JSON) to diagnose server/static asset availability.\n        await page.goto(\"http://127.0.0.1:5174/health\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120437927483//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.087Z",
    "modified": "2026-02-03T12:13:36.348Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "2e8fe267-5830-42ba-b75f-d7ef87f2e5d7",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC019-Session re-evaluation after role change",
    "description": "Verify that changing a user's role while they have an active session causes access level changes according to the system's session-policy (immediate re-eval or after re-login).",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly to allow SPA to initialize, then reload the page (navigate to the same URL) and re-check for interactive elements/login UI. If still blank, proceed to diagnostics.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the application in a new browser tab (navigate to the same URL in a new tab) to see whether the SPA loads there and to collect interactive elements/login UI for continuing authentication and role-change tests.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the application in a fresh new tab (navigate to the same URL in a new tab) to attempt loading the SPA and collect interactive elements. If that also fails, proceed to alternate diagnostics (try /index.html, /login, or 127.0.0.1 host).\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt alternative URL to load SPA assets (try /index.html). Wait for the page to load and then re-check for interactive elements and login/dashboard UI. If still blank, plan next: try http://127.0.0.1:5174 or /login in a new tab.\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the application using the loopback address (http://127.0.0.1:5174) in a new tab to check whether the SPA loads there; if it also fails, plan next steps (/login, check /index.html already tried, or collect diagnostics).\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab targeting a likely login endpoint variant (http://127.0.0.1:5174/login) and wait briefly for the page to load so interactive elements (login form) can be detected.\n        await page.goto(\"http://127.0.0.1:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120331537598//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.093Z",
    "modified": "2026-02-03T12:13:36.356Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "f5cf7aa2-8ffc-4cdb-8b5b-705bd82918de",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC020-Server-side validation for vehicle fields (unique, format checks)",
    "description": "Verify server enforces validation rules (VIN format, unique plate per org, required fields) and returns appropriate validation error responses.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Find API or server endpoints to run the vehicle-creation tests (try /api and vehicle endpoints). Attempt to access an API listing or health endpoint to determine correct POST URL for vehicle creation.\n        await page.goto(\"http://localhost:5174/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button on the error page to retry connecting to the local server, then wait for the page to respond.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try to directly open the vehicles API endpoint to see if the backend is reachable and supports vehicle creation (GET/POST /api/vehicles). If that fails, try /api/health or /api/docs next.\n        await page.goto(\"http://localhost:5174/api/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend health by requesting http://localhost:5174/api/health to determine if the API server is reachable and returns a status. If that fails, try /api or /api/docs next.\n        await page.goto(\"http://localhost:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button (interactive element index 74) to retry connecting to the local server and then re-check the API endpoints if the page recovers.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try direct navigation to the API using the loopback IP and common docs endpoints (start by opening http://127.0.0.1:5174/api/vehicles in a new tab and wait for a response). If that fails, try other doc endpoints (/docs, /swagger.json) next.\n        await page.goto(\"http://127.0.0.1:5174/api/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to discover reachable API endpoints or docs (swagger/openapi/docs) using loopback variants. If endpoints are unreachable, report server unreachable and stop so user can restart the server.\n        await page.goto(\"http://127.0.0.1:5174/swagger.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://127.0.0.1:5174/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/177012028291215//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.098Z",
    "modified": "2026-02-03T12:13:36.364Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "ed3af5c6-6484-42f7-a55b-4dc5818a0a64",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC021-Trip status state machine and invalid transition rejection",
    "description": "Verify valid trip state transitions are allowed (scheduled -> in_progress -> completed/cancelled) and invalid transitions are rejected by backend.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend API endpoint to interact directly (try /api and /api/trips) so a trip can be created and transitions exercised.\n        await page.goto(\"http://localhost:5174/api/trips\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button on the error page to retry connecting to the backend and load /api/trips response.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Check backend availability by requesting the API root /api to obtain server status or error message, so test plan can proceed if server responds.\n        await page.goto(\"http://localhost:5174/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to reload the page by waiting briefly then clicking the Reload button (element index 74). If the click fails again, stop repeated attempts and use an alternative navigation strategy.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try direct navigation to the backend trips API endpoint to attempt trip creation (use go_to_url since no clickable navigation elements exist). If the API is still unreachable, stop and report failure.\n        await page.goto(\"http://localhost:5174/api/trips\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120166311273//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.104Z",
    "modified": "2026-02-03T12:13:36.373Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "ab157457-1a28-4c84-b5be-8b49d8fa2725",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC022-Financial calculations precision and currency edge cases",
    "description": "Verify calculations (totals, net profit) use correct decimal precision and currency handling and correctly handle zero/very large amounts.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app in a new tab (2nd navigation attempt) to force SPA load, wait for the page to initialize, then re-check interactive elements. If still blank, try reload or report website issue.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Totals and Net Profit displayed with correct decimal precision and currency handling').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected a confirmation that totals and net profit are displayed with correct decimal precision and proper currency handling (including zero and very large amounts). The success indicator did not appear â€” this suggests rounding/truncation errors, incorrect currency conversion/handling, or the UI failed to render calculation results.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120233835559//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.109Z",
    "modified": "2026-02-03T12:13:36.381Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "06cdaa6e-d65f-41bf-8efb-93f9e7ce9d40",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC023-Audit logging for critical operations",
    "description": "Verify create/update/delete actions on critical entities (vehicles, trips, assets, expenses, roles) are recorded in audit_logs with user_id, org_id, operation, timestamp and diff where applicable.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try explicit app entry route (login) to bypass SPA root load issue and expose the login/dashboard so tests can continue.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try alternative entry route: navigate to /dashboard, wait for the SPA to initialize, then scroll to reveal UI. If still blank, prepare to report site issue or try different navigation.\n        await page.goto(\"http://localhost:5174/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120149845209//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.115Z",
    "modified": "2026-02-03T12:13:36.390Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "eeec27c7-09db-4db1-8de3-f3c6f8751ed9",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC024-Write authorization: org_id must match authenticated user's org",
    "description": "Ensure server rejects writes where payload org_id does not match authenticated user's org_id preventing privilege elevation by forging org_id.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the login page or reload the SPA so the UI becomes available (reload root or navigate to /login). If UI remains blank, prepare to interact with API endpoints directly.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the SPA (navigate to root) and wait for the page to initialize. If the UI remains blank, proceed to test the backend API endpoints directly (authenticate as Org1 and attempt create/update requests).\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend API root to check availability and then attempt authentication as Org1 via the API (if endpoints exist).\n        await page.goto(\"http://localhost:5174/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the visible Reload button on the error page to try to re-establish connection to the server. If the reload keeps failing, stop and report server unavailable so user can start the service.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the API authentication endpoint in a new tab to verify backend availability (try http://localhost:5174/api/auth/login). If unreachable, try alternate host (http://127.0.0.1:5174) or health endpoints, then report server unavailable so user can start the service.\n        await page.goto(\"http://localhost:5174/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the API auth endpoint using 127.0.0.1 (http://127.0.0.1:5174/api/auth/login) in a new tab to check whether the backend responds.\n        await page.goto(\"http://127.0.0.1:5174/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://127.0.0.1:5174 (root) to check if server responds. If still unreachable, check /api and /api/health and then report server unavailable so the user can start the backend.\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend health endpoint http://127.0.0.1:5174/api/health (new tab) to check backend availability. If unreachable, report server unavailable and request user to start the service so tests can continue.\n        await page.goto(\"http://127.0.0.1:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120307276568//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.121Z",
    "modified": "2026-02-03T12:13:36.398Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "fd0a1c81-52a0-4940-b43b-696c197e2054",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC025-Authentication security: password policy and brute-force protection",
    "description": "Verify password complexity policy is enforced at account creation, password change, and that repeated failed login attempts trigger rate limiting or account lockout as configured.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:5174/login to try to reach the login or registration UI; inspect for interactive elements. If blank, try /register and /signup; if still blank, report website issue and stop.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:5174/register, wait briefly for the SPA to initialize, then inspect the page for interactive elements (login/register forms). If still blank, plan next navigation to /signup.\n        await page.goto(\"http://localhost:5174/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button to retry loading the site and then re-inspect the page for interactive elements (forms or links).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open a new browser tab and navigate to http://localhost:5174 to reload the app from a clean tab, then inspect the page for interactive elements (login/register forms).\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a fresh tab to the site using alternate host (127.0.0.1) to see if the SPA loads (http://127.0.0.1:5174). If that fails, plan next: try direct API/health endpoint or report website issue.\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend availability by requesting the health/status API endpoint to determine if the service is up and to find API routes for account creation and authentication. If health endpoint responds, use API endpoints for password complexity and rate-limit tests; if not, report website issue.\n        await page.goto(\"http://127.0.0.1:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend API endpoints directly (start with /api/auth/register) and return raw HTTP response body and any visible headers/Content-Type so account creation and auth tests can proceed via API if the SPA remains unavailable.\n        await page.goto(\"http://127.0.0.1:5174/api/auth/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the login API endpoint and return the raw HTTP response (body and any visible Content-Type/headers) so API-based testing can continue if available.\n        await page.goto(\"http://127.0.0.1:5174/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120378113485//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.128Z",
    "modified": "2026-02-03T12:13:36.406Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "ae5cde8d-d68f-497f-bbbe-436279e94244",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC026-Frontend environment configuration validation",
    "description": "Verify the app fails fast with clear errors when critical environment variables (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY) are missing or invalid and prevents unsafe behavior.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page (navigate to the same URL) to surface any dev server / HTML error output. If the page remains blank, request or collect devserver/terminal logs and restart the frontend with the VITE_SUPABASE_URL missing as the next step.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```python\n        try:\n            await expect(frame.locator('text=Configuration error: Missing VITE_SUPABASE_URL').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the app to fail fast and display a clear configuration error indicating the missing VITE_SUPABASE_URL and to block login attempts, but no such error message or blocking behavior was observed.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120121951399//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.134Z",
    "modified": "2026-02-03T12:13:36.414Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "1fb504a4-eb35-4978-8938-9fd9a5d80ab4",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC027-Basic accessibility checks on key screens",
    "description": "Verify key screens (login, dashboard, fleet list, vehicle edit) meet basic accessibility guidelines: keyboard navigable, ARIA roles present on interactive elements, and meaningful alt/labels.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to allow SPA to finish loading (wait), scroll to reveal content, then reload the page if still blank.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page (force a full reload) and wait for the SPA to initialize; then re-check the page for interactive elements and begin accessibility checks on login screen.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the site in a new tab (full reload) and wait for the SPA to initialize, then re-check the page for interactive elements and begin accessibility checks on the login screen.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button (index 74) to attempt to recover the site, then wait for the SPA to initialize and re-check for interactive elements.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the site in a new tab using an alternate host (http://127.0.0.1:5174) to attempt a fresh connection, then wait for the SPA to initialize and re-check for interactive elements.\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open http://127.0.0.1:5174/index.html in a new tab, wait 5 seconds for a response, then re-check the page for interactive elements to continue accessibility checks.\n        await page.goto(\"http://127.0.0.1:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120880518832//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.139Z",
    "modified": "2026-02-03T12:14:41.637Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "357c5144-ea39-44c3-ad60-22ef1651e1bb",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC028-In-app notifications for vehicle maintenance status changes",
    "description": "Verify that when a vehicle's status is changed to 'maintenance', appropriate in-app notifications/alerts appear for relevant users (fleet managers) and link to the vehicle record.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application page to force the SPA to load. If still blank, try navigating directly to the login route (/login) or open a new tab to retry.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the login route (/login) in the current tab to attempt to load the SPA login page.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new browser tab and load http://localhost:5174/login to attempt loading the SPA there.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the visible Reload button (index 74) to attempt reloading the page and recover the SPA.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120882795947//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.149Z",
    "modified": "2026-02-03T12:14:44.084Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "36ffc378-b447-423b-a4fd-429d3188274f",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC029-Concurrent edits and conflict handling for vehicle records",
    "description": "Test concurrent updates to the same vehicle record from two sessions and verify conflict resolution strategy (optimistic locking or last-write-wins) is applied and documented.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the application in a new tab to attempt to load the SPA, then locate login or dashboard elements so sessions can be opened.\n        await page.goto(\"http://localhost:5174/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try navigating directly to the login page to force the SPA route to render (try /login). If that fails, try alternative entry points (/#/login, /index.html) or report website issue.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the hash-based login route (http://localhost:5174/#/login) to attempt to load the SPA route. If that fails, next will be /index.html or try other entry points.\n        await page.goto(\"http://localhost:5174/#/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:5174/index.html in the current tab to attempt to force the SPA to render; if that fails, plan alternative entry points or report website issue.\n        await page.goto(\"http://localhost:5174/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the SPA using an alternative host (127.0.0.1) with a cache-busting query parameter to bypass any cached broken assets and see if the UI renders.\n        await page.goto(\"http://127.0.0.1:5174/?_ts=1700000000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to access the backend API for vehicle #1 to retrieve its JSON and confirm an API exists that can be used to simulate concurrent updates. If vehicle endpoint responds, use API-based steps to perform concurrent GET/PUT to simulate SessionA and SessionB updates; if no API found, report website issue and stop.\n        await page.goto(\"http://127.0.0.1:5174/api/vehicles/1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the vehicles API index (/api/vehicles) and extract the full response body; if that returns nothing, try the trailing-slash variant for vehicle #1 (/api/vehicles/1/) and extract the body. If APIs remain empty, report website issue.\n        await page.goto(\"http://127.0.0.1:5174/api/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the trailing-slash vehicle API endpoint (/api/vehicles/1/) and extract the full response body so the concurrency test can proceed via API if SPA remains unavailable.\n        await page.goto(\"http://127.0.0.1:5174/api/vehicles/1/\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120890041873//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.155Z",
    "modified": "2026-02-03T12:14:51.188Z"
  },
  {
    "projectId": "0afd59b9-8d5b-47a3-871c-2adc13958b80",
    "testId": "7eed7def-9c6d-44e8-9964-c87ee83df926",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC030-Deletion safety and cascade rules for vehicles with dependent records",
    "description": "Verify behavior when deleting vehicles that have dependent trips, expenses, or assets: either prevent deletion or cascade per the business rules and ensure no orphaned records remain.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5174\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the login page (/login) so the SPA can initialize; if login page appears, proceed with test login using test credentials and then create vehicle + dependent records via UI or API as available.\n        await page.goto(\"http://localhost:5174/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to recover the SPA by forcing a reload: scroll (in case content appears on scroll), wait, then navigate to http://localhost:5174 to reload the app and wait for it to initialize. If still blank, plan to try http://127.0.0.1:5174 on next step.\n        await page.goto(\"http://localhost:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://127.0.0.1:5174 to see if the SPA loads from the loopback address; wait for the page to initialize and check interactive elements.\n        await page.goto(\"http://127.0.0.1:5174\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try the backend API endpoints (e.g., /api) to create records and run delete tests because the SPA/UI is not loading. First action: navigate to http://127.0.0.1:5174/api to check for an API response or health endpoint.\n        await page.goto(\"http://127.0.0.1:5174/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://127.0.0.1:5174/api/vehicles to check whether the backend exposes a vehicles endpoint or returns a JSON/health response. If blank, subsequent steps will try /api/health and /api/trips.\n        await page.goto(\"http://127.0.0.1:5174/api/vehicles\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check another backend endpoint for a raw JSON/health response (try /api/trips). If that is empty, plan to try /api/health and then consider POST operations to create test records if endpoints respond.\n        await page.goto(\"http://127.0.0.1:5174/api/trips\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend health endpoint for a JSON response (try /api/health) to determine whether the backend is alive and which endpoints are available. If /api/health returns JSON, plan to use API calls to create vehicle and dependent records; if it is blank, consider alternate diagnostics (different host/port or server logs).\n        await page.goto(\"http://127.0.0.1:5174/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1770120890963165//tmp/test_task/result.webm",
    "created": "2026-02-03T11:59:15.163Z",
    "modified": "2026-02-03T12:14:52.095Z"
  }
]
